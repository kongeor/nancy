/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gr.cons.nancy.lang;

import gr.cons.nancy.parser.NancyLexer;
import gr.cons.nancy.parser.NancyParser;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class App {

    public static void main(String[] args) throws IOException {
//        var code = "(let [x 1 y true] (if y x (inc x)))";
        var code = """
                   (let [f (fn [x : bool]
                             (fn [y : bool]
                               y))]
                     (let [g (fn [x : bool]
                              (fn [y : bool]
                                y))]
                        (if true
                           f
                           g)))
                   """;
//        var code = "(1 :(bool -> int))";
//        var code = "(let [f (fn [x : int 1] (if true 1 x))] (if true (f 10) 1))";
//        var code = "(let [f : (int -> bool) (fn [x : int 1] (if true true false))] (if true (f 10) 1))";
//        var code = "(let [x : int 1] (- x true))";
        var inputStream = CharStreams.fromString(code);
        var lexer = new NancyLexer(inputStream);
        var tokenStream = new CommonTokenStream(lexer);
        var parser = new NancyParser(tokenStream);

        var expr = readExpr(parser.expr());
        System.out.println(expr);
        System.out.println(Checker.typeOf(expr, new Env()));
    }

    public static NancyExpr readExpr(NancyParser.ExprContext expr) {
        TerminalNode anInt = expr.INT();
        TerminalNode anSymb = expr.SYMB();
        NancyParser.Type_exprContext aType = expr.type_expr();
        List<NancyParser.ExprContext> expr1 = expr.expr();
        if (anInt != null) {
            return new NumExpr(Integer.parseInt(anInt.getText()));
        } else if (anSymb != null) {
            String text = anSymb.getText();
            if (text.equals("true") || text.equals("false")) {
                return new BoolExpr(Boolean.parseBoolean(text));
            }
            else if (text.equals("nil")) {
                // todo const
                return new NilExpr();
            }
            return new SymbExpr(anSymb.getText(), Optional.empty());
        } else if (aType != null) {
            return readType(aType);
        }
        // list
        else if (expr1 != null) {
            NancyParser.ExprContext exprContext = expr1.getFirst();
            if (exprContext.SYMB() != null) {
                String symbName = exprContext.SYMB().getText();
                if (symbName.equals("if")) {
                    return new IfExpr(readExpr(expr1.get(1)), readExpr(expr1.get(2)), readExpr(expr1.get(3)));
                } else if (symbName.equals("let")) {
                    SymbExpr bindName = (SymbExpr) readExpr(expr1.get(1).expr(0));
                    NancyExpr bindTypeOrVal = readExpr(expr1.get(1).expr(1));
                    boolean hasType = bindTypeOrVal instanceof NancyType;
                    SymbExpr symb = hasType ? new SymbExpr(bindName.val(), Optional.of((NancyType) bindTypeOrVal)) :bindName;
                    NancyExpr body = readExpr(expr1.get(2));
                    NancyExpr val = hasType ? readExpr(expr1.get(1).expr(2)) : bindTypeOrVal;
                    return new LetExpr(symb, val, body);
                } else if (symbName.equals("fn")) {
                    NancyExpr nancyExpr = readExpr(expr1.get(1).expr(0));
                    NancyType type = null;
                    if (expr1.get(1).expr(1) != null) {
                        type = (NancyType) readExpr(expr1.get(1).expr(1));
                    }
                    SymbExpr typedExpr = type != null ? new SymbExpr(((SymbExpr)nancyExpr).val(), Optional.of(type)) : (SymbExpr) nancyExpr;
                    return new FnExpr(typedExpr, readExpr(expr1.get(2)));
                } else if (symbName.equals("-")) {
                    return new DiffExpr(readExpr(expr1.get(1)), readExpr(expr1.get(2)));
                } else {
                    return new CallExpr(readExpr(expr1.get(0)), readExpr(expr1.get(1)));
                }
            }
        }
        throw new IllegalArgumentException("Don't know what to do with " + expr1);
    }

    public static NancyType readType(NancyParser.Type_exprContext expr) {
        if (expr.INT_TYPE() != null) {
            return new IntType();
        } else if (expr.BOOL_TYPE() != null) {
            return new BoolType();
        } else {
            List<NancyParser.Type_exprContext> typeExprContexts = expr.type_expr();
            return new FuncType(readType(typeExprContexts.get(0)), readType(typeExprContexts.get(1)));
        }
    }

    // types
    public sealed interface NancyType extends NancyExpr permits BoolType, IntType, FuncType {}

    public record BoolType() implements NancyType {}
    public record IntType() implements NancyType {}
    public record FuncType(NancyType from, NancyType to) implements NancyType {}

    // exprs
    public sealed interface NancyExpr permits NancyType, SymbExpr, BoolExpr, NumExpr, NilExpr, DiffExpr, IfExpr, LetExpr, FnExpr, CallExpr, Cons {}

    public record SymbExpr(String val, Optional<NancyType> type) implements NancyExpr {

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            SymbExpr symbExpr = (SymbExpr) o;
            return Objects.equals(val, symbExpr.val);
        }

        @Override
        public int hashCode() {
            return Objects.hash(val);
        }
    }
    public record BoolExpr(boolean val) implements NancyExpr {}
    public record NumExpr(Integer val) implements NancyExpr {}

    public record NilExpr() implements NancyExpr {
        public static final NilExpr NIL = new NilExpr();
    }

    public record DiffExpr(NancyExpr e1, NancyExpr e2) implements NancyExpr {}

    public record IfExpr(NancyExpr e1, NancyExpr e2, NancyExpr e3) implements NancyExpr {}
    // todo multiple binding
    public record LetExpr(NancyExpr varName, NancyExpr varVal, NancyExpr body) implements NancyExpr {}
    public record FnExpr(NancyExpr binding, NancyExpr body) implements NancyExpr {}
    public record CallExpr(NancyExpr rator, NancyExpr rand) implements NancyExpr {}
}
